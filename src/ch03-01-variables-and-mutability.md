## Променливи и Променимост

Както е споменато в раздела [“Съхранение на Стойности в Променливи
”][storing-values-with-variables]<!-- ignore -->, променливите са непроменими
по подразбиране. Това е едно от многото подтиквания, които Ви дава Rust, за да
пишете код по такъв начин, че да се възползвате от сигурността и лесното
конкурентно програмиране, което предлага Rust. Все пак имате опцията да
направите променливите си променими. Нека разгледаме как и защо Rust Ви
насърчава да предпочитате непроменимост и защо понякога бихте искали да не се
възползвате.

Когато дадена променлива е непроменима, веднъж да се обвърже стойност с нея,
повече не можете да промените тази стойност. За да демонстрираме това, създайте
нов проект с името *variables* във Вашата директория *projects* чрез `cargo new
variables`.

После във Вашата директория *variables* отворете *src/main.rs* и заменете кода
вътре с следния код, който още няма да се компилира:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

Запазете и изпълнете програмата с `cargo run`. Трябва да получите съобщение за
грешка с непроменимостта, както е показано в този изход:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

Този пример показва как компилатора Ви помага да намерите грешки в програмите
си. Грешките от компилатора могат да бъдат обезсърчаващи, но те просто
означават, че програмата Ви не прави това, което искате тя да прави, безопасно;
те *не* означават, че не сет добър програмист! Оптни Rustaceans все още получват
грешки от компилатора.

Получили сте съобщението за грешка `` cannot assign twice to immutable variable
`x` ``, защото сте се опитали за присвоите втора стойност на непроменимата
променлива `x`.

Важно е да получаваме грешки по време на компилация, когато се опитваме да
променим стойност, която е определена като непроменима, защото точно тази
ситуация може да доведе до бъгове. Ако някоя част от кода ни работи на
предположението, че дадена стойност няма да се промени, а друга част от кода ни
промени тази стойност, е възможно първата част да не свърши това, което сме я
направили да върши. Причината на този вид бъгове може да е трудна за откриване
пост-фактум, особено ако втората част променя стойността само *понякога*.
Компилатора на Rust гарантира, че когато декларирате, че променлива няма да се
променя, тя наистина няма да се промени, за да не се налада Вие да следите за
това. Така кода Ви е лесен за премисляне.

Но променимостта може да е много полезна и може да направи кода по-лесен за
писане. Въпреки че променливите са непроменими по подразбиране, Вие можете да ги
направите променими като добавите `mut` пред името на променливата, както
направихте в [глава 2][storing-values-with-variables]<!-- ignore -->. Добавянето
на `mut` също предава намерението към хора, които ще четат кода в бъдеще, че
други части на кода ще променят стойността на тази променлива.

Например, нека променим *src/main.rs* да изглежда така:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

Когато изпълним програмата сега, получавме следното:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

Можем да променим стойността обвързана с `x` от `5` на `6`, когато ползваме
`mut`. В крайна сметка, решението дали да ползваме или да не ползваме
променимост е Ваше и зависи от това как мислите, че е по-ясно в дадената
ситуация.

### Константи

Като непроменими променливи, *константи* са стойности, които са обвързани с име
и не могат да се променят, но има няколко разлики между константи и промнливи.

Първо, не можете да ползвате `mut` върху константи. Константите не са само
непроменими по подразбиране, те винаги са непроменими. Константи се декларират
чрез ключовата дума `const` вместо `let` и типа на променливата *задължително*
трябва да е анотиран. Ще покрием типове и типови анотации в следващия раздел -
["Типове Данни"][data-types]<!-- ignore -->, така че сега не се притеснявайте за
детайлите. Само знайте, че задължително трябва да анотирате типа.

Константите могат да бъдат декларирани в който и да е обхват, включително в
глобалния, което ги прави полезни за стойности, които много части от кода трябва
да знаят.

Последната разлика е, че на константите могат да бъдат присвоени само константни
израси, не резултата от стойност, която може само да бъде изчислена по време на
изпълнение.

Ето пример на декларация на константа:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Името на константата е `THREE_HOURS_IN_SECONDS` и стойността и е зададена да е
резултата от умножението на 60 (броя секунди в една минута) по 60 (броя минути в
един час) по 3 (броя часове, който искаме да броим в тази програма). Конвенцията
на Rust за именъване на константи е да се използват само главни букви с долни
черти между думите. Компилатора може да изпълни ограничено множество от операции
по време на компилация, което ни позволява да изберем да изпишем тази стойност
по начин, който е по-лесен за разбиране и потвърждаване, вместо задаването на
стойността на тази константа 10 800. Вижте [раздела за пресмятане на константи
от Наръчника на Rust][const-eval] за повече информация за кои операции могат да
се използват при декларация на константи.

Константите са валидни за цялото изпълнение на програмата в обхвата, в който са
декларирани. Това свойство ги прави удобни за стойности от областта на Вашето
приложение, които трябва да се знаят от няколко части на програмата, като
максималният брой точки, които може да спечели играч в игра, или скоростта на
светлината.

Даването на имена на твърдо-закодирани стойности, които се ползват във Вашата
програма като константи, е полезно в предаването на значението на тази стойност
към хора, които ще поддържат този код в бъдещето. Също помага да има само едно
място в кода Ви, което ще трябва да промените ако твърдо-закодираната стойност
трябва да се промени в бъдеще.

### Скриване

Както видяхте в урока с играта за отгатване в [глава
2][comparing-the-guess-to-the-secret-number]<!-- ignore -->, можете да
декларирате нова променлив със същото име като предишна променлива. Rustaceans
казват, че първата променлива е *скрита* от втората, което означава, че втората
променливата ще е това, което вижда компилатора когато ползвате това име. На
практика втората променлива крие първата, взимайки всяко ползване на името за
себе си докато тя самата не бъде скрита или свърши обхвата. Можем да скрием
променлива като ползваме същото име и повторно ползвайки ключовата дума `let`
както следва:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

Тази програма първо обвързва `x` със стойността `5`. След това създава нова
променлива `x` повтаряйки `let x =`, взимайки първоначалната стойност и
добавяйки `1`, така че стойността на `x` е `6`. После във вътрешния обхват
създаден с къдравите скоби, третата декларация `let` също скрива `x` и създава
нова променлива умножавайки предишната стойност по `2`, за да даде на `x`
стойността `12`. Когато този обхват свърши, вътрешното скриване свършва и `x`
става пак `6`. Когато изпълним програмата, тя ще изведе следното:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

Скриването е различно от дефинирането на променлива с `mut`, защото ще получим
грешка по време на компилация, ако без да искаме се опитаме да презапишем тази
променлива без да ползваме ключовата дума `let`. Ползвайки `let` можем да
приложим няколко трансформации върху стойност, но променливата да бъде
непроменима след като са готови трансформациите.

Другата разлика между `mut` и скриването е, че можем да сменим типа на
стойността и да преизползваме името, защото на практика създаваме нова
променлива. Например, ако нашата програма пита потребителя да покаже колко
знака за отстояние искат между някакъв текст, като въведат знаци за отстояние,
и после искаме да запазим въведеното като число:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

Първата променлива `spaces` е от низов тип, а втората - от числов тип. Така
скриването ни помага да не се налага да мислим нови имена като `spaces_str` и
`spaces_num`; вместо това, можем да преизползваме по-простото `spaces`. Обаче
ако се опитаме да ползваме `mut` за това, както е показано, ще получим грешка
по време на компилация:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Грешката гласи, че не можем да меним типа на променливата:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

Сега като сме разгледали как работят променливите, нека разгледаме повече типве
данни, които могат да имат.

[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#Съхранение-на-Стойности-в-Променливи
[const-eval]: ../reference/const_eval.html
